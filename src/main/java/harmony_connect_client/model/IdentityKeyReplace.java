/*
 * Harmony Connect
 * An easy to use API that helps you access the Factom blockchain.
 *
 * OpenAPI spec version: 1.0.19
 * Contact: harmony-support@factom.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package harmony_connect_client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * IdentityKeyReplace
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2019-07-03T22:54:40.268681300Z[UTC]")
public class IdentityKeyReplace {
  public static final String SERIALIZED_NAME_OLD_KEY = "old_key";
  @SerializedName(SERIALIZED_NAME_OLD_KEY)
  private String oldKey;

  public static final String SERIALIZED_NAME_NEW_KEY = "new_key";
  @SerializedName(SERIALIZED_NAME_NEW_KEY)
  private String newKey;

  public static final String SERIALIZED_NAME_SIGNER_KEY = "signer_key";
  @SerializedName(SERIALIZED_NAME_SIGNER_KEY)
  private String signerKey;

  public static final String SERIALIZED_NAME_SIGNATURE = "signature";
  @SerializedName(SERIALIZED_NAME_SIGNATURE)
  private String signature;

  public static final String SERIALIZED_NAME_CALLBACK_URL = "callback_url";
  @SerializedName(SERIALIZED_NAME_CALLBACK_URL)
  private String callbackUrl;

  public static final String SERIALIZED_NAME_CALLBACK_STAGES = "callback_stages";
  @SerializedName(SERIALIZED_NAME_CALLBACK_STAGES)
  private List<String> callbackStages = new ArrayList<String>();

  public IdentityKeyReplace oldKey(String oldKey) {
    this.oldKey = oldKey;
    return this;
  }

   /**
   * The public key you would like to replace. This should be sent as a Base58 string in IdPub format.
   * @return oldKey
  **/
  @ApiModelProperty(required = true, value = "The public key you would like to replace. This should be sent as a Base58 string in IdPub format.")
  public String getOldKey() {
    return oldKey;
  }

  public void setOldKey(String oldKey) {
    this.oldKey = oldKey;
  }

  public IdentityKeyReplace newKey(String newKey) {
    this.newKey = newKey;
    return this;
  }

   /**
   * The public key that you would like to activate. This should be sent as a Base58 string in IdPub format.
   * @return newKey
  **/
  @ApiModelProperty(required = true, value = "The public key that you would like to activate. This should be sent as a Base58 string in IdPub format.")
  public String getNewKey() {
    return newKey;
  }

  public void setNewKey(String newKey) {
    this.newKey = newKey;
  }

  public IdentityKeyReplace signerKey(String signerKey) {
    this.signerKey = signerKey;
    return this;
  }

   /**
   * The key you are using to authorize the replacement. Must be equal to or higher level than the key you want to replace. This should be sent as a Base58 string in IdPub format.
   * @return signerKey
  **/
  @ApiModelProperty(required = true, value = "The key you are using to authorize the replacement. Must be equal to or higher level than the key you want to replace. This should be sent as a Base58 string in IdPub format.")
  public String getSignerKey() {
    return signerKey;
  }

  public void setSignerKey(String signerKey) {
    this.signerKey = signerKey;
  }

  public IdentityKeyReplace signature(String signature) {
    this.signature = signature;
    return this;
  }

   /**
   * A signature that proves ownership of the &#x60;signer_key&#x60;. This signature should use the [Ed25519](https://ed25519.cr.yp.to/) specification. The signed message should be the Identity Chain ID, the Old Key, and the New Key in that order. The message should be a single string with no whitespace or separators between the three parts.
   * @return signature
  **/
  @ApiModelProperty(required = true, value = "A signature that proves ownership of the `signer_key`. This signature should use the [Ed25519](https://ed25519.cr.yp.to/) specification. The signed message should be the Identity Chain ID, the Old Key, and the New Key in that order. The message should be a single string with no whitespace or separators between the three parts.")
  public String getSignature() {
    return signature;
  }

  public void setSignature(String signature) {
    this.signature = signature;
  }

  public IdentityKeyReplace callbackUrl(String callbackUrl) {
    this.callbackUrl = callbackUrl;
    return this;
  }

   /**
   * The URL where you would like to receive the callback from Connect. If this is not specified, callbacks will not activate.
   * @return callbackUrl
  **/
  @ApiModelProperty(value = "The URL where you would like to receive the callback from Connect. If this is not specified, callbacks will not activate.")
  public String getCallbackUrl() {
    return callbackUrl;
  }

  public void setCallbackUrl(String callbackUrl) {
    this.callbackUrl = callbackUrl;
  }

  public IdentityKeyReplace callbackStages(List<String> callbackStages) {
    this.callbackStages = callbackStages;
    return this;
  }

  public IdentityKeyReplace addCallbackStagesItem(String callbackStagesItem) {
    if (this.callbackStages == null) {
      this.callbackStages = new ArrayList<String>();
    }
    this.callbackStages.add(callbackStagesItem);
    return this;
  }

   /**
   * The stages that you would like to trigger a callback from Connect. This list can include any or all of the three stages: &#x60;replicated&#x60;, &#x60;factom&#x60;, and &#x60;anchored&#x60;. If callbacks are activated and this field is not sent, it will default to &#x60;factom&#x60; and &#x60;anchored&#x60;
   * @return callbackStages
  **/
  @ApiModelProperty(value = "The stages that you would like to trigger a callback from Connect. This list can include any or all of the three stages: `replicated`, `factom`, and `anchored`. If callbacks are activated and this field is not sent, it will default to `factom` and `anchored`")
  public List<String> getCallbackStages() {
    return callbackStages;
  }

  public void setCallbackStages(List<String> callbackStages) {
    this.callbackStages = callbackStages;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IdentityKeyReplace identityKeyReplace = (IdentityKeyReplace) o;
    return Objects.equals(this.oldKey, identityKeyReplace.oldKey) &&
        Objects.equals(this.newKey, identityKeyReplace.newKey) &&
        Objects.equals(this.signerKey, identityKeyReplace.signerKey) &&
        Objects.equals(this.signature, identityKeyReplace.signature) &&
        Objects.equals(this.callbackUrl, identityKeyReplace.callbackUrl) &&
        Objects.equals(this.callbackStages, identityKeyReplace.callbackStages);
  }

  @Override
  public int hashCode() {
    return Objects.hash(oldKey, newKey, signerKey, signature, callbackUrl, callbackStages);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IdentityKeyReplace {\n");
    sb.append("    oldKey: ").append(toIndentedString(oldKey)).append("\n");
    sb.append("    newKey: ").append(toIndentedString(newKey)).append("\n");
    sb.append("    signerKey: ").append(toIndentedString(signerKey)).append("\n");
    sb.append("    signature: ").append(toIndentedString(signature)).append("\n");
    sb.append("    callbackUrl: ").append(toIndentedString(callbackUrl)).append("\n");
    sb.append("    callbackStages: ").append(toIndentedString(callbackStages)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}


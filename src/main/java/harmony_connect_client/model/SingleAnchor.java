/*
 * Harmony Connect
 * An easy to use API that helps you access the Factom blockchain.
 *
 * OpenAPI spec version: 1.0.19
 * Contact: harmony-support@factom.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package harmony_connect_client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import harmony_connect_client.model.DBlockLink;
import harmony_connect_client.model.MerkleNode;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * SingleAnchor
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2019-07-03T22:54:40.268681300Z[UTC]")
public class SingleAnchor {
  /**
   * Indicates the blockchain network that contains this anchor.
   */
  @JsonAdapter(NetworkEnum.Adapter.class)
  public enum NetworkEnum {
    BITCOIN("bitcoin"),
    
    ETHEREUM("ethereum"),
    
    FACTOM("factom");

    private String value;

    NetworkEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NetworkEnum fromValue(String text) {
      for (NetworkEnum b : NetworkEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + text + "'");
    }

    public static class Adapter extends TypeAdapter<NetworkEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NetworkEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NetworkEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return NetworkEnum.fromValue(String.valueOf(value));
      }
    }
  }

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private NetworkEnum network;

  /**
   * The confirmation status of the anchor. Either pending or confirmed.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    PENDING("pending"),
    
    CONFIRMED("confirmed");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + text + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StatusEnum.fromValue(String.valueOf(value));
      }
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_TX_ID = "tx_id";
  @SerializedName(SERIALIZED_NAME_TX_ID)
  private String txId;

  public static final String SERIALIZED_NAME_BLOCK_HASH = "block_hash";
  @SerializedName(SERIALIZED_NAME_BLOCK_HASH)
  private String blockHash;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private String createdAt;

  public static final String SERIALIZED_NAME_ENTRY_SERIALIZED = "entry_serialized";
  @SerializedName(SERIALIZED_NAME_ENTRY_SERIALIZED)
  private String entrySerialized;

  public static final String SERIALIZED_NAME_ENTRY_HASH = "entry_hash";
  @SerializedName(SERIALIZED_NAME_ENTRY_HASH)
  private String entryHash;

  public static final String SERIALIZED_NAME_DBLOCK = "dblock";
  @SerializedName(SERIALIZED_NAME_DBLOCK)
  private DBlockLink dblock = null;

  public static final String SERIALIZED_NAME_MERKLE_BRANCH = "merkle_branch";
  @SerializedName(SERIALIZED_NAME_MERKLE_BRANCH)
  private List<MerkleNode> merkleBranch = new ArrayList<MerkleNode>();

  public static final String SERIALIZED_NAME_WINDOW_START_HEIGHT = "window_start_height";
  @SerializedName(SERIALIZED_NAME_WINDOW_START_HEIGHT)
  private Integer windowStartHeight;

  public static final String SERIALIZED_NAME_WINDOW_MR = "window_mr";
  @SerializedName(SERIALIZED_NAME_WINDOW_MR)
  private String windowMr;

  public static final String SERIALIZED_NAME_CONTRACT_ADDRESS = "contract_address";
  @SerializedName(SERIALIZED_NAME_CONTRACT_ADDRESS)
  private String contractAddress;

  public static final String SERIALIZED_NAME_TX_INDEX = "tx_index";
  @SerializedName(SERIALIZED_NAME_TX_INDEX)
  private Integer txIndex;

  public SingleAnchor network(NetworkEnum network) {
    this.network = network;
    return this;
  }

   /**
   * Indicates the blockchain network that contains this anchor.
   * @return network
  **/
  @ApiModelProperty(required = true, value = "Indicates the blockchain network that contains this anchor.")
  public NetworkEnum getNetwork() {
    return network;
  }

  public void setNetwork(NetworkEnum network) {
    this.network = network;
  }

  public SingleAnchor status(StatusEnum status) {
    this.status = status;
    return this;
  }

   /**
   * The confirmation status of the anchor. Either pending or confirmed.
   * @return status
  **/
  @ApiModelProperty(required = true, value = "The confirmation status of the anchor. Either pending or confirmed.")
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }

  public SingleAnchor txId(String txId) {
    this.txId = txId;
    return this;
  }

   /**
   * Only returned for confirmed bitcoin or ethereum anchors. The bitcoin or ethereum transaction ID for the transaction that includes the anchor message.
   * @return txId
  **/
  @ApiModelProperty(value = "Only returned for confirmed bitcoin or ethereum anchors. The bitcoin or ethereum transaction ID for the transaction that includes the anchor message.")
  public String getTxId() {
    return txId;
  }

  public void setTxId(String txId) {
    this.txId = txId;
  }

  public SingleAnchor blockHash(String blockHash) {
    this.blockHash = blockHash;
    return this;
  }

   /**
   * Only returned for confirmed bitcoin or ethereum anchors. The hash of the bitcoin or ethereum block that contains the anchor message.
   * @return blockHash
  **/
  @ApiModelProperty(value = "Only returned for confirmed bitcoin or ethereum anchors. The hash of the bitcoin or ethereum block that contains the anchor message.")
  public String getBlockHash() {
    return blockHash;
  }

  public void setBlockHash(String blockHash) {
    this.blockHash = blockHash;
  }

  public SingleAnchor createdAt(String createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * Only returned for confirmed factom anchors. The time at which this entry was created. Sent in [ISO 8601 Format](https://en.wikipedia.org/wiki/ISO_8601). For example: &#x60;YYYY-MM-DDThh:mm:ss.ssssssZ&#x60; This will be null if the chain is not at least at the &#x60;factom&#x60; immutability stage.
   * @return createdAt
  **/
  @ApiModelProperty(value = "Only returned for confirmed factom anchors. The time at which this entry was created. Sent in [ISO 8601 Format](https://en.wikipedia.org/wiki/ISO_8601). For example: `YYYY-MM-DDThh:mm:ss.ssssssZ` This will be null if the chain is not at least at the `factom` immutability stage.")
  public String getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(String createdAt) {
    this.createdAt = createdAt;
  }

  public SingleAnchor entrySerialized(String entrySerialized) {
    this.entrySerialized = entrySerialized;
    return this;
  }

   /**
   * Only returned for confirmed factom anchors. The raw data that makes up the entry.
   * @return entrySerialized
  **/
  @ApiModelProperty(value = "Only returned for confirmed factom anchors. The raw data that makes up the entry.")
  public String getEntrySerialized() {
    return entrySerialized;
  }

  public void setEntrySerialized(String entrySerialized) {
    this.entrySerialized = entrySerialized;
  }

  public SingleAnchor entryHash(String entryHash) {
    this.entryHash = entryHash;
    return this;
  }

   /**
   * Only returned for confirmed factom anchors. The unique identitfier of the entry.
   * @return entryHash
  **/
  @ApiModelProperty(value = "Only returned for confirmed factom anchors. The unique identitfier of the entry.")
  public String getEntryHash() {
    return entryHash;
  }

  public void setEntryHash(String entryHash) {
    this.entryHash = entryHash;
  }

  public SingleAnchor dblock(DBlockLink dblock) {
    this.dblock = dblock;
    return this;
  }

   /**
   * Get dblock
   * @return dblock
  **/
  @ApiModelProperty(value = "")
  public DBlockLink getDblock() {
    return dblock;
  }

  public void setDblock(DBlockLink dblock) {
    this.dblock = dblock;
  }

  public SingleAnchor merkleBranch(List<MerkleNode> merkleBranch) {
    this.merkleBranch = merkleBranch;
    return this;
  }

  public SingleAnchor addMerkleBranchItem(MerkleNode merkleBranchItem) {
    if (this.merkleBranch == null) {
      this.merkleBranch = new ArrayList<MerkleNode>();
    }
    this.merkleBranch.add(merkleBranchItem);
    return this;
  }

   /**
   * Only returned for confirmed factom or ethereum anchors. The branch of the merkle tree that represents this anchor. Presented as an array of Merkle nodes.
   * @return merkleBranch
  **/
  @ApiModelProperty(value = "Only returned for confirmed factom or ethereum anchors. The branch of the merkle tree that represents this anchor. Presented as an array of Merkle nodes.")
  public List<MerkleNode> getMerkleBranch() {
    return merkleBranch;
  }

  public void setMerkleBranch(List<MerkleNode> merkleBranch) {
    this.merkleBranch = merkleBranch;
  }

  public SingleAnchor windowStartHeight(Integer windowStartHeight) {
    this.windowStartHeight = windowStartHeight;
    return this;
  }

   /**
   * Only returned for confirmed ethereum anchors. The height of the first ethereum block that contains an anchor for this directory block. Valid anchors for the Directory block in question may also be contained in subsequent ethereum blocks.
   * @return windowStartHeight
  **/
  @ApiModelProperty(value = "Only returned for confirmed ethereum anchors. The height of the first ethereum block that contains an anchor for this directory block. Valid anchors for the Directory block in question may also be contained in subsequent ethereum blocks.")
  public Integer getWindowStartHeight() {
    return windowStartHeight;
  }

  public void setWindowStartHeight(Integer windowStartHeight) {
    this.windowStartHeight = windowStartHeight;
  }

  public SingleAnchor windowMr(String windowMr) {
    this.windowMr = windowMr;
    return this;
  }

   /**
   * Only returned for confirmed ethereum anchors. Window Merkle Root. This is the Merkle root that was published in the ethereum transaction that anchors this directory block. The root represents every one of the 1000 Directory blocks that's included in this anchor.
   * @return windowMr
  **/
  @ApiModelProperty(value = "Only returned for confirmed ethereum anchors. Window Merkle Root. This is the Merkle root that was published in the ethereum transaction that anchors this directory block. The root represents every one of the 1000 Directory blocks that's included in this anchor.")
  public String getWindowMr() {
    return windowMr;
  }

  public void setWindowMr(String windowMr) {
    this.windowMr = windowMr;
  }

  public SingleAnchor contractAddress(String contractAddress) {
    this.contractAddress = contractAddress;
    return this;
  }

   /**
   * Only returned for confirmed ethereum anchors. The address of the contract that initiated the anchor transaction.
   * @return contractAddress
  **/
  @ApiModelProperty(value = "Only returned for confirmed ethereum anchors. The address of the contract that initiated the anchor transaction.")
  public String getContractAddress() {
    return contractAddress;
  }

  public void setContractAddress(String contractAddress) {
    this.contractAddress = contractAddress;
  }

  public SingleAnchor txIndex(Integer txIndex) {
    this.txIndex = txIndex;
    return this;
  }

   /**
   * Only returned for confirmed ethereum anchors. The index of the transaction within the block.
   * @return txIndex
  **/
  @ApiModelProperty(value = "Only returned for confirmed ethereum anchors. The index of the transaction within the block.")
  public Integer getTxIndex() {
    return txIndex;
  }

  public void setTxIndex(Integer txIndex) {
    this.txIndex = txIndex;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SingleAnchor singleAnchor = (SingleAnchor) o;
    return Objects.equals(this.network, singleAnchor.network) &&
        Objects.equals(this.status, singleAnchor.status) &&
        Objects.equals(this.txId, singleAnchor.txId) &&
        Objects.equals(this.blockHash, singleAnchor.blockHash) &&
        Objects.equals(this.createdAt, singleAnchor.createdAt) &&
        Objects.equals(this.entrySerialized, singleAnchor.entrySerialized) &&
        Objects.equals(this.entryHash, singleAnchor.entryHash) &&
        Objects.equals(this.dblock, singleAnchor.dblock) &&
        Objects.equals(this.merkleBranch, singleAnchor.merkleBranch) &&
        Objects.equals(this.windowStartHeight, singleAnchor.windowStartHeight) &&
        Objects.equals(this.windowMr, singleAnchor.windowMr) &&
        Objects.equals(this.contractAddress, singleAnchor.contractAddress) &&
        Objects.equals(this.txIndex, singleAnchor.txIndex);
  }

  @Override
  public int hashCode() {
    return Objects.hash(network, status, txId, blockHash, createdAt, entrySerialized, entryHash, dblock, merkleBranch, windowStartHeight, windowMr, contractAddress, txIndex);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SingleAnchor {\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    txId: ").append(toIndentedString(txId)).append("\n");
    sb.append("    blockHash: ").append(toIndentedString(blockHash)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    entrySerialized: ").append(toIndentedString(entrySerialized)).append("\n");
    sb.append("    entryHash: ").append(toIndentedString(entryHash)).append("\n");
    sb.append("    dblock: ").append(toIndentedString(dblock)).append("\n");
    sb.append("    merkleBranch: ").append(toIndentedString(merkleBranch)).append("\n");
    sb.append("    windowStartHeight: ").append(toIndentedString(windowStartHeight)).append("\n");
    sb.append("    windowMr: ").append(toIndentedString(windowMr)).append("\n");
    sb.append("    contractAddress: ").append(toIndentedString(contractAddress)).append("\n");
    sb.append("    txIndex: ").append(toIndentedString(txIndex)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}


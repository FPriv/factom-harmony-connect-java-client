/*
 * Harmony Connect
 * An easy to use API that helps you access the Factom blockchain.
 *
 * OpenAPI spec version: 1.0.19
 * Contact: harmony-support@factom.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package harmony_connect_client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import harmony_connect_client.model.MerkleNode;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * EthereumAnchor
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2019-07-03T22:54:40.268681300Z[UTC]")
public class EthereumAnchor {
  /**
   * Indicates the blockchain network that contains this anchor.
   */
  @JsonAdapter(NetworkEnum.Adapter.class)
  public enum NetworkEnum {
    BITCOIN("bitcoin"),
    
    ETHEREUM("ethereum"),
    
    FACTOM("factom");

    private String value;

    NetworkEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NetworkEnum fromValue(String text) {
      for (NetworkEnum b : NetworkEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + text + "'");
    }

    public static class Adapter extends TypeAdapter<NetworkEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NetworkEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NetworkEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return NetworkEnum.fromValue(String.valueOf(value));
      }
    }
  }

  public static final String SERIALIZED_NAME_NETWORK = "network";
  @SerializedName(SERIALIZED_NAME_NETWORK)
  private NetworkEnum network;

  /**
   * The confirmation status of the anchor. Either pending or confirmed.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    PENDING("pending"),
    
    CONFIRMED("confirmed");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String text) {
      for (StatusEnum b : StatusEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + text + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StatusEnum.fromValue(String.valueOf(value));
      }
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private StatusEnum status;

  public static final String SERIALIZED_NAME_WINDOW_START_HEIGHT = "window_start_height";
  @SerializedName(SERIALIZED_NAME_WINDOW_START_HEIGHT)
  private Integer windowStartHeight;

  public static final String SERIALIZED_NAME_WINDOW_MR = "window_mr";
  @SerializedName(SERIALIZED_NAME_WINDOW_MR)
  private String windowMr;

  public static final String SERIALIZED_NAME_MERKLE_BRANCH = "merkle_branch";
  @SerializedName(SERIALIZED_NAME_MERKLE_BRANCH)
  private List<MerkleNode> merkleBranch = new ArrayList<MerkleNode>();

  public static final String SERIALIZED_NAME_CONTRACT_ADDRESS = "contract_address";
  @SerializedName(SERIALIZED_NAME_CONTRACT_ADDRESS)
  private String contractAddress;

  public static final String SERIALIZED_NAME_TX_ID = "tx_id";
  @SerializedName(SERIALIZED_NAME_TX_ID)
  private String txId;

  public static final String SERIALIZED_NAME_TX_INDEX = "tx_index";
  @SerializedName(SERIALIZED_NAME_TX_INDEX)
  private Integer txIndex;

  public static final String SERIALIZED_NAME_BLOCK_HASH = "block_hash";
  @SerializedName(SERIALIZED_NAME_BLOCK_HASH)
  private String blockHash;

  public EthereumAnchor network(NetworkEnum network) {
    this.network = network;
    return this;
  }

   /**
   * Indicates the blockchain network that contains this anchor.
   * @return network
  **/
  @ApiModelProperty(required = true, value = "Indicates the blockchain network that contains this anchor.")
  public NetworkEnum getNetwork() {
    return network;
  }

  public void setNetwork(NetworkEnum network) {
    this.network = network;
  }

  public EthereumAnchor status(StatusEnum status) {
    this.status = status;
    return this;
  }

   /**
   * The confirmation status of the anchor. Either pending or confirmed.
   * @return status
  **/
  @ApiModelProperty(required = true, value = "The confirmation status of the anchor. Either pending or confirmed.")
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }

  public EthereumAnchor windowStartHeight(Integer windowStartHeight) {
    this.windowStartHeight = windowStartHeight;
    return this;
  }

   /**
   * The height of the first ethereum block that contains an anchor for this directory block. Valid anchors for the Directory block in question may also be contained in subsequent ethereum blocks.
   * @return windowStartHeight
  **/
  @ApiModelProperty(value = "The height of the first ethereum block that contains an anchor for this directory block. Valid anchors for the Directory block in question may also be contained in subsequent ethereum blocks.")
  public Integer getWindowStartHeight() {
    return windowStartHeight;
  }

  public void setWindowStartHeight(Integer windowStartHeight) {
    this.windowStartHeight = windowStartHeight;
  }

  public EthereumAnchor windowMr(String windowMr) {
    this.windowMr = windowMr;
    return this;
  }

   /**
   * Window Merkle Root. This is the Merkle root that was published in the ethereum transaction that anchors this directory block. The root represents every one of the 1000 Directory blocks that's included in this anchor.
   * @return windowMr
  **/
  @ApiModelProperty(value = "Window Merkle Root. This is the Merkle root that was published in the ethereum transaction that anchors this directory block. The root represents every one of the 1000 Directory blocks that's included in this anchor.")
  public String getWindowMr() {
    return windowMr;
  }

  public void setWindowMr(String windowMr) {
    this.windowMr = windowMr;
  }

  public EthereumAnchor merkleBranch(List<MerkleNode> merkleBranch) {
    this.merkleBranch = merkleBranch;
    return this;
  }

  public EthereumAnchor addMerkleBranchItem(MerkleNode merkleBranchItem) {
    if (this.merkleBranch == null) {
      this.merkleBranch = new ArrayList<MerkleNode>();
    }
    this.merkleBranch.add(merkleBranchItem);
    return this;
  }

   /**
   * The merkle branch that leads to the Directory block in question. Relates to the Window Merkle root. Presented as an array of Merkle nodes.
   * @return merkleBranch
  **/
  @ApiModelProperty(value = "The merkle branch that leads to the Directory block in question. Relates to the Window Merkle root. Presented as an array of Merkle nodes.")
  public List<MerkleNode> getMerkleBranch() {
    return merkleBranch;
  }

  public void setMerkleBranch(List<MerkleNode> merkleBranch) {
    this.merkleBranch = merkleBranch;
  }

  public EthereumAnchor contractAddress(String contractAddress) {
    this.contractAddress = contractAddress;
    return this;
  }

   /**
   * The address of the contract that initiated the anchor transaction.
   * @return contractAddress
  **/
  @ApiModelProperty(value = "The address of the contract that initiated the anchor transaction.")
  public String getContractAddress() {
    return contractAddress;
  }

  public void setContractAddress(String contractAddress) {
    this.contractAddress = contractAddress;
  }

  public EthereumAnchor txId(String txId) {
    this.txId = txId;
    return this;
  }

   /**
   * The ethereum transaction ID for the transaction that includes the anchor message.
   * @return txId
  **/
  @ApiModelProperty(value = "The ethereum transaction ID for the transaction that includes the anchor message.")
  public String getTxId() {
    return txId;
  }

  public void setTxId(String txId) {
    this.txId = txId;
  }

  public EthereumAnchor txIndex(Integer txIndex) {
    this.txIndex = txIndex;
    return this;
  }

   /**
   * The index of the transaction within the block.
   * @return txIndex
  **/
  @ApiModelProperty(value = "The index of the transaction within the block.")
  public Integer getTxIndex() {
    return txIndex;
  }

  public void setTxIndex(Integer txIndex) {
    this.txIndex = txIndex;
  }

  public EthereumAnchor blockHash(String blockHash) {
    this.blockHash = blockHash;
    return this;
  }

   /**
   * The hash of the ethereum block that contains the anchor transaction.
   * @return blockHash
  **/
  @ApiModelProperty(value = "The hash of the ethereum block that contains the anchor transaction.")
  public String getBlockHash() {
    return blockHash;
  }

  public void setBlockHash(String blockHash) {
    this.blockHash = blockHash;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EthereumAnchor ethereumAnchor = (EthereumAnchor) o;
    return Objects.equals(this.network, ethereumAnchor.network) &&
        Objects.equals(this.status, ethereumAnchor.status) &&
        Objects.equals(this.windowStartHeight, ethereumAnchor.windowStartHeight) &&
        Objects.equals(this.windowMr, ethereumAnchor.windowMr) &&
        Objects.equals(this.merkleBranch, ethereumAnchor.merkleBranch) &&
        Objects.equals(this.contractAddress, ethereumAnchor.contractAddress) &&
        Objects.equals(this.txId, ethereumAnchor.txId) &&
        Objects.equals(this.txIndex, ethereumAnchor.txIndex) &&
        Objects.equals(this.blockHash, ethereumAnchor.blockHash);
  }

  @Override
  public int hashCode() {
    return Objects.hash(network, status, windowStartHeight, windowMr, merkleBranch, contractAddress, txId, txIndex, blockHash);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EthereumAnchor {\n");
    sb.append("    network: ").append(toIndentedString(network)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    windowStartHeight: ").append(toIndentedString(windowStartHeight)).append("\n");
    sb.append("    windowMr: ").append(toIndentedString(windowMr)).append("\n");
    sb.append("    merkleBranch: ").append(toIndentedString(merkleBranch)).append("\n");
    sb.append("    contractAddress: ").append(toIndentedString(contractAddress)).append("\n");
    sb.append("    txId: ").append(toIndentedString(txId)).append("\n");
    sb.append("    txIndex: ").append(toIndentedString(txIndex)).append("\n");
    sb.append("    blockHash: ").append(toIndentedString(blockHash)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}


/*
 * Harmony Connect
 * An easy to use API that helps you access the Factom blockchain.
 *
 * OpenAPI spec version: 1.0.19
 * Contact: harmony-support@factom.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package harmony_connect_client.api;

import harmony_connect_client.ApiException;

import harmony_connect_client.*;
import harmony_connect_client.auth.*;
import harmony_connect_client.model.*;
import harmony_connect_client.ApiException;
import harmony_connect_client.model.AnchorLong;
import harmony_connect_client.model.ErrorMessage;
import harmony_connect_client.model.SearchResult;
import harmony_connect_client.model.ReceiptLong;
import harmony_connect_client.model.Chain;
import harmony_connect_client.model.ChainCreate;
import harmony_connect_client.model.ChainList;
import harmony_connect_client.model.ChainShort;
import harmony_connect_client.model.SearchBody;
import static org.junit.Assert.*;
import org.junit.Test;
import org.junit.Ignore;
import org.junit.BeforeClass;
import org.junit.Assert;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

/**
 * API tests for ProofsApi
 */
public class ProofsApiTest {
    static ProofsApi api;
    static String testChainId;
    static String testEntryHash;
    String timeNonce = Base64.getEncoder().encodeToString((System.currentTimeMillis()+"").getBytes());
    String testExtId = "ZXhhbXBsZS1leHRpZA==";

    private static class SetUpResults {
        String testChainId;
        String testEntryHash;
        ChainsApi chainsApi;
        ProofsApi proofsApi;
    }

    @BeforeClass
    public static void setUp() {
        ProofsApiTest obj = new ProofsApiTest();
        SetUpResults setupResults = obj.setUpHelper();
        api = setupResults.proofsApi;
        testChainId = setupResults.testChainId;
        //testEntryHash = setupResults.testEntryHash;
        // Since we don't want to wait for confirmations, use a hard-coded entry hash for now.
        //testEntryHash = "ec2ea3e6ac578943263e1e087fd0971e688040e99e5730ef0c284762566c319c"; // matisse
        testEntryHash = "0c55aa0ddd0cc932fdb428f76976289a79e41222efdf7e0eee7d8cc32b92a65e"; // ephemeral
    }

    public SetUpResults setUpHelper() {
        InputStream inputStream = null;
        String baseurl;
        String appid;
        String appkey;
        ProofsApi newProofsApi = null;
        ChainsApi newChainsApi = null;
        String newTestChainId = "";
        String newTestEntryHash = "";

		try {
			Properties prop = new Properties();

			inputStream = getClass().getClassLoader().getResourceAsStream("config.properties");
			if (inputStream != null) {
				prop.load(inputStream);
			} else {
				throw new FileNotFoundException("config.properties file not found in the classpath");
			}

			baseurl = prop.getProperty("baseurl");
			appid = prop.getProperty("appid");
            appkey = prop.getProperty("appkey");

            ApiClient defaultClient = Configuration.getDefaultApiClient();
            defaultClient.setBasePath(baseurl);
            ApiKeyAuth AppId = (ApiKeyAuth) defaultClient.getAuthentication("AppId");
            AppId.setApiKey(appid);
            ApiKeyAuth AppKey = (ApiKeyAuth) defaultClient.getAuthentication("AppKey");
            AppKey.setApiKey(appkey);
            newProofsApi = new ProofsApi();
            newChainsApi = new ChainsApi();
		} catch (Exception e) {
			System.out.println("Exception: " + e);
		} finally {
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
            } catch (Exception e) {
                System.out.println("Exception: " + e);
            }
        }

        /*
        ChainCreate chainCreate = new ChainCreate();
        List<String> externalIds = Arrays.asList(testExtId, timeNonce);
        String content = "ZXhhbXBsZS1jb250ZW50";
        chainCreate.externalIds(externalIds);
        chainCreate.content(content);
        try {
            ChainShort response = newChainsApi.postChain(chainCreate);
            newTestChainId = response.getChainId();
            newTestEntryHash = response.getEntryHash();
            assertFalse(newTestChainId.isEmpty());
        } catch (Exception e) {
			System.out.println("Exception: " + e);
		}
        */
        SetUpResults result = new SetUpResults();
        result.proofsApi = newProofsApi;
        result.chainsApi = newChainsApi;
        result.testChainId = newTestChainId;
        result.testEntryHash = newTestEntryHash;
        return result;
    }

    
    /**
     * Get Object's Anchors
     *
     * Retreive the blockchain anchors of an entry, chain, or block. Returns an array of anchors that may be of type ethereum, bitcoin, or factom. The valid identifiers for the objects that can be anchored are as follows:  * Entry - Entry Hash * Chain - Chain ID * Directory Block - Height or Key Merkle Root * Entry Block - Key Merkle Root * Factoid Block - Key Merkle Root
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getAnchorbySearchTest() throws ApiException {
        AnchorLong response = api.getAnchorbySearch(testEntryHash);

        assertFalse(response.getData().getDblock().toString().isEmpty());
        assertFalse(response.getData().getAnchors().size() < 1);
    }
    
    /**
     * Get Entry's Receipts
     *
     * Retrieve a receipt providing cryptographically verifiable proof that information was recorded in the Factom blockchain.
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getReceiptsbyEntryTest() throws ApiException {
        ReceiptLong response = api.getReceiptsbyEntry(testEntryHash);

        assertFalse(response.getData().getEntryHash().isEmpty());
        assertFalse(response.getData().getEntrySerialized().isEmpty());
        assertFalse(response.getData().getMerkleBranch().size() < 2);
        assertFalse(response.getData().getEblock().toString().isEmpty());
        assertFalse(response.getData().getDblock().toString().isEmpty());
    }
    
    /**
     * Search
     *
     * Search for something on the Factom blockchain. You may search for Directory Blocks (by height or key Merkle root), Entry Blocks (by key Merkle root), Factoid Blocks (by key Merkle root), Chains (by Chain ID), Entries (by Entry Hash), Addresses (by user address or address), and Transactions (by transaction ID).
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void getSearchTest() throws ApiException {
        SearchResult response = api.getSearch(testEntryHash, "factom");

        assertFalse(response.getData().toString().isEmpty());
    }

}
